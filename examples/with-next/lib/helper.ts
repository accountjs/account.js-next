import { Signer } from 'ethers'
import { formatEther, formatUnits, parseEther, parseUnits } from 'ethers/lib/utils.js'
import { LOCAL_CONFIG } from '@/config'
import { admin } from './instances'
import { Currency, PaymasterMode } from './type'
import { Address, erc20ABI } from 'wagmi'
import { fetchBalance, getContract, prepareWriteContract, writeContract } from 'wagmi/actions'

const { usdt, weth, tokenAddr, wethPaymaster, usdtPaymaster, fixedPaymaster, gaslessPaymaster } =
  LOCAL_CONFIG

export const parseExpectedGas = (e: Error): Error => {
  // parse a custom error generated by the BundlerHelper, which gives a hint of how much payment is missing
  const match = e.message?.match(/paid (\d+) expected (\d+)/)
  if (match != null) {
    const paid = Math.floor(parseInt(match[1]) / 1e9)
    const expected = Math.floor(parseInt(match[2]) / 1e9)
    return new Error(
      `Error: Paid ${paid}, expected ${expected} . Paid ${Math.floor(
        (paid / expected) * 100
      )}%, missing ${expected - paid} `
    )
  }
  return e
}

const MODE_PAYMASTER_MAP = {
  [PaymasterMode.usdt]: usdtPaymaster,
  [PaymasterMode.weth]: wethPaymaster,
  [PaymasterMode.gasless]: gaslessPaymaster,
  [PaymasterMode.token]: fixedPaymaster
}

export const faucet = async (address: Address, token?: Currency) => {
  const requiredBalance = parseEther('1')

  switch (token) {
    case Currency.ether: {
      const bal = await fetchBalance({ address })
      if (bal.value.lt(requiredBalance)) {
        await admin.sendTransaction({
          to: address,
          value: requiredBalance.sub(bal.value)
        })
      }
      break
    }
    case Currency.weth: {
      const bal = await fetchBalance({ address, token: weth })
      if (bal.value.lt(requiredBalance)) {
        const requiredAmount = requiredBalance.sub(bal.value)
        // wrap ETH to WETH
        await admin.sendTransaction({
          to: weth,
          value: requiredAmount
        })

        const config = await prepareWriteContract({
          address: weth,
          abi: erc20ABI,
          functionName: 'transfer',
          args: [address, requiredAmount],
          signer: admin
        })
        await writeContract(config).then((tx) => tx.wait())
      }
      break
    }
    case Currency.usdt: {
      const requiredUSD = parseUnits('50000', 8)
      const bal = await fetchBalance({ address, token: usdt })
      if (bal.value.lt(requiredUSD)) {
        const config = await prepareWriteContract({
          address: usdt,
          abi: erc20ABI,
          functionName: 'transfer',
          args: [address, requiredUSD.sub(bal.value)],
          signer: admin
        })
        await writeContract(config).then((tx) => tx.wait())
      }
      break
    }
    case Currency.token: {
      const requiredTok = parseEther('1')
      const ERC20Token = getContract({
        address: tokenAddr,
        abi: [
          ...erc20ABI,
          {
            inputs: [
              {
                internalType: 'address',
                name: 'sender',
                type: 'address'
              },
              {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256'
              }
            ],
            name: 'mint',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
          }
        ] as const,
        signerOrProvider: admin
      })
      const args = [admin.address as Address, parseEther('1')] as const
      const estimateGas = await ERC20Token.estimateGas.mint(...args)
      await ERC20Token.mint(...args, { gasLimit: estimateGas.mul(3).div(2) }).catch((e) =>
        console.log(e)
      )
      await ERC20Token.transfer(address, requiredTok).then((tx) => tx.wait())
      break
    }
    default: {
      throw new Error('Unknown token')
    }
  }
}

// export const transfer = async (
//   currency: Currency,
//   target: Address,
//   amount: string,
//   aaProvider: ERC4337EthersProvider,
// ) => {
//   switch (currency) {
//     case Currency.ether: {
//       // const op = await aaProvider
//       //   .getSigner()
//       //   .smartAccountAPI.createSignedUserOp({
//       //     target,
//       //     data: "0x00",
//       //     value: parseEther(amount),
//       //   })
//       // const hash = await aaProvider.httpRpcClient.sendUserOpToBundler(op)
//       // console.log("ðŸš€ ~ file: helper.ts:305 ~ hash:", hash)
//       await aaProvider.getSigner().sendTransaction({
//         to: target,
//         value: parseEther(amount),
//       })
//       break
//     }
//     case Currency.weth:
//     case Currency.usdt:
//     case Currency.token: {
//       const tokenAddress = TOKEN_ADDRESS_MAP[currency]
//       const tokenContract = ERC20__factory.connect(tokenAddress, aaProvider)
//       const decimals = await tokenContract.decimals()
//       const data = ERC20__factory.createInterface().encodeFunctionData(
//         "transfer",
//         [target, parseUnits(amount, decimals)],
//       )
//       await aaProvider.getSigner().sendTransaction({
//         data,
//         to: tokenAddress,
//       })
//       break
//     }
//     default: {
//       throw new Error("Unknown token")
//     }
//   }
// }
